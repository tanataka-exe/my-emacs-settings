#+TITLE: Emacs Config
#+PROPERTY: :header-args :exports code :tangle init.el
* Emacs初期設定
このファイルはEmacsの初期化設定をOrgモードで記述している。

読み込むには~/.emacs.d/init.elの最初の行に

    (org-babel-load-file (expand-file-name "~/.emacs.d/custom-init.org"))
    
を記載して再起動すること。
** 動作条件
DDSKKを使っているので、~/.emacs.d/SKK-JISYO.Lが配置されていることを前提にしている。
また、~/.emacs.d/themesディレクトリと~/.emacs.d/extensions/themesディレクトリにテーマファイルが存在していることも必要。

*** インストールが必要なパッケージ

+ ddskk
+ ccc … これはddskkをインストールする時に自動的にインストールされるのかもしれない。
+ cdb … これもddskkの依存パッケージかもしれない。よくわからない。
+ markdown-mode
+ web-mode

*** 配置が必要なファイル

+ ~/.emacs.d/SKK-JISYO.L

** パッケージの初期化 package-initialization
パッケージ管理機能の設定

#+BEGIN_SRC emacs-lisp
  (package-initialize)
  (require 'package)
  (add-to-list 'package-archives (cons "melpa" "http://melpa.org/packages/") t)
  (defun adjust-package-installation (use-package)
    (dolist (package use-package)
      (unless (package-installed-p package)
        (package-install package))))
#+END_SRC


** カスタム・テーマのロード・パスを設定する load-paths-for-themes

#+BEGIN_SRC emacs-lisp
  (add-to-list 'custom-theme-load-path "~/repo/github.com/aharotias2/emacs-utils")
  (add-to-list 'custom-theme-load-path "~/.emacs.d/extensions/themes")
  (add-to-list 'custom-theme-load-path "~/.emacs.d/themes")
#+END_SRC

** 自作ライブラリのロード・パスを追加

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/lisp")
#+END_SRC

** モード有効化

#+BEGIN_SRC emacs-lisp
  (global-font-lock-mode t)
#+END_SRC

** ファイル関連付け file-association

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.org\\'" . org-mode))
  (add-to-list 'auto-mode-alist '("\\.log\\'" . text-mode))
  (add-to-list 'auto-mode-alist '("\\.php\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.html\\'" . web-mode))
#+END_SRC

** フレームサイズ frame-sizing

*** 好みのフレームサイズを設定する

#+BEGIN_SRC emacs-lisp
  ;;(add-to-list 'default-frame-alist '(left   . 50))
  ;;(add-to-list 'default-frame-alist '(top    . 0))
  (add-to-list 'default-frame-alist '(height . 45))
  (add-to-list 'default-frame-alist '(width  . 120))
#+END_SRC

*** init-frame関数
好みのウィンドウ設定
スクロールバー：表示する
メニューバー：表示する
ツールバー：表示しない

#+BEGIN_SRC emacs-lisp
  (defun init-frame()
    (message "init-frame was called")
    (scroll-bar-mode 0)
    (menu-bar-mode 0)
    (tool-bar-mode 0)
    ;;(set-frame-size (selected-frame) 120 45)
    (setq line-spacing 0)
    (set-window-scroll-bars (minibuffer-window) nil nil))
#+END_SRC

フレームの初期設定実行

#+BEGIN_SRC emacs-lisp
  (init-frame)
#+END_SRC

*** create-new-frame関数
新規のフレーム (ウィンドウ) を開き、好みの設定を反映する。

#+BEGIN_SRC emacs-lisp
  (defun create-new-frame ()
    "新しいウィンドウ (フレーム) を開いた時に大きさやスクロールバーなどを調整する。"
    (select-frame (make-frame))
    (init-frame))
#+END_SRC

*** フレームを新規作成したときのカスタムフックを設定する

#+BEGIN_SRC emacs-lisp
  (add-hook 'before-make-frame-hook
            (lambda ()
              (init-frame)))
  (add-hook 'server-after-make-frame-hook
            (lambda ()
              (init-frame)))
#+END_SRC

** カスタム関数 custom-functions
*** 16進数系関数
**** dec2hex関数 - 10進数を16進数に変換

#+BEGIN_SRC emacs-lisp
  (defun dec2hex (decimal)
    (if (or (stringp decimal) (numberp decimal))
        (let ((s "") (n (if (stringp decimal)
                            (string-to-number decimal)
                          decimal)))
          (while (> n 0)
            (let ((m (% n 16)))
              (setq s (if (< m 10)
                          (format "%d%s" m s)
                        (format "%s%s"
                                (cond ((= m 10) "A")
                                      ((= m 11) "B")
                                      ((= m 12) "C")
                                      ((= m 13) "D")
                                      ((= m 14) "E")
                                      ((= m 15) "F"))
                                s))))
            (setq n (/ n 16)))
          s)
      (message "Wrong Type Of Arguments (string or number is required)")))
#+END_SRC

**** hex2dec関数 - 16進数を10進数に変換

#+BEGIN_SRC emacs-lisp
  (defun hex2dec (hex)
    (cl-flet
        ((one-hex (lambda (c)
                    (cond ((= c ?0) 0) ((= c ?1) 1)
                          ((= c ?2) 2) ((= c ?3) 3)
                          ((= c ?4) 4) ((= c ?5) 5)
                          ((= c ?6) 6) ((= c ?7) 7)
                          ((= c ?8) 8) ((= c ?9) 9)
                          ((or (= c ?A) (= c ?a)) 10)
                          ((or (= c ?B) (= c ?b)) 11)
                          ((or (= c ?C) (= c ?c)) 12)
                          ((or (= c ?D) (= c ?d)) 13)
                          ((or (= c ?E) (= c ?e)) 14)
                          ((or (= c ?F) (= c ?f)) 15)))))
      (seq-reduce (lambda (sum num)
                    (+ (* sum 16) (one-hex num)))
                  (append hex nil)
                  0)))
#+END_SRC

**** rgb-shade関数

#+BEGIN_SRC emacs-lisp
  (defun rgb-shade (rgb ratio)
    (let ((r (hex2dec (substring rgb 0 2)))
          (g (hex2dec (substring rgb 2 4)))
          (b (hex2dec (substring rgb 4 6))))
      (kill-new (concat (dec2hex (< 255 (floor (* r ratio))))
                        (dec2hex (< 255 (floor (* g ratio))))
                        (dec2hex (< 255 (floor (* b ratio))))))))
#+END_SRC

*** 数値関数
**** less関数 - 比較関数

#+BEGIN_SRC emacs-lisp
(defun less (a b)
  (if (< a b) a b))
#+END_SRC
*** 時間関数
**** time-sum関数 - 時間を合計する

#+BEGIN_SRC emacs-lisp
  (defun time-sum(time-list)
    "時間のリストを受け取り、合計の時間を返す。時間は分の数値と秒の数値のリストで表します。
  例：(time-sum '((1 29) (4 40) (2 20)))
  これは「\"1:29\" + \"4:40\" + \"2:20\"」を表し、\"08:29\"を返す。"
    (if (not (listp time-list))
        nil
      (cl-flet ((decode (lambda (time-item)
                          (let ((minutes (car time-item))
                                (seconds (car (cdr time-item))))
                            (+ (* 60 minutes) seconds))))
                (encode (lambda (seconds)
                          (format "%02d:%02d" (/ seconds 60) (% seconds 60)))))
        (let ((sum-seconds 0))
          (dolist (time-item time-list)
            (setq sum-seconds (+ sum-seconds (decode time-item))))
          (encode sum-seconds)))))
#+END_SRC

*** 文字系関数
**** count-chars関数 - 文字数を数える
選択されたリージョン内の文字数を数える。

#+BEGIN_SRC emacs-lisp
  (defun count-chars ()
    "This function counts number of characters which in a region selected."
    (interactive)
    (princ (format "The number of characters: %d" (- (region-end) (region-beginning)))))
#+END_SRC
**** string-join関数 - 文字列を連結
文字列を連結する。(開始文字列、連結文字列、終了文字列を指定する)

#+BEGIN_SRC emacs-lisp
  (defun string-join (start-mark end-mark delim-mark list &optional func)
    "This function makes a string formatted as 'start-mark + delimitted-list + end-mark'
  where delimitted-list is a string that each elements of the list are concatanated separated by the delim-mark."
    (let ((elem-func (if (null func) (lambda (e) e) func)))
      (concat start-mark (mapconcat elem-func list delim-mark) end-mark)))
#+END_SRC

**** repeat-chars関数 - 反復文字列の作成
数同じ文字を繰り返す文字列を作る。

#+BEGIN_SRC emacs-lisp
  (defun repeat-chars(num str)
    (let ((i 0) (ret ""))
      (while (< i num)
        (setq ret (append ret str)))))
#+END_SRC

しかしmake-string関数で良いみたいだな。

**** delete-backward-word関数
カーソル位置の直前にある単語を削除する

#+BEGIN_SRC emacs-lisp
  (defun delete-backward-word ()
    (set-mark (point))
    (backward-word)
    (delete-region (point) (mark)))
#+END_SRC

**** untabify-all関数
バッファ全体を選択し、untabifyする。カーソルは元の位置に戻る。

#+BEGIN_SRC emacs-lisp
  (defun untabify-all ()
    "バッファ全体にuntabify関数を適用する"
    (interactive)
    (point-to-register ?p)
    (mark-whole-buffer)
    (untabify (point-min) (point-max))
    (jump-to-register ?p)
    (deactivate-mark))
#+END_SRC

*** ファイル系関数
**** file-basename関数
ファイルパスのファイル名部分を返す

#+BEGIN_SRC emacs-lisp
(defun file-basename (file-path)
  "この関数はファイルパスのファイル名部分を返す。"
  (concat (file-name-base file-path)
          (if (not (null (file-name-extension file-path)))
              ".")
          (file-name-extension file-path)))
#+END_SRC

**** set-default-mode-for-file関数 - ファイル関連付け
これ使ってたっけ？

#+BEGIN_SRC emacs-lisp
  (defun set-default-mode-for-file (arg-list)
    (dolist (key-value arg-list)
      (if (and (has-value (car key-value)) (has-value (cdr key-value)))
          (add-to-list 'auto-mode-alist (cons (concat "\\" (car key-value) "\\'") (cdr key-value))))))
#+END_SRC

**** rename-file-and-buffer関数
現在編集中のバッファと、ファイル名を同時に変更する。

#+BEGIN_SRC emacs-lisp
  (defun rename-file-and-buffer (new-name)
    "Renames both current buffer and file it's visiting to NEW-NAME."
    (interactive "sNew name: ")
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not filename)
          (message "Buffer '%s' is not visiting a file!" name)
        (if (get-buffer new-name)
            (message "A buffer named '%s' already exists!" new-name)
          (progn
            (rename-file filename new-name 1)
            (rename-buffer new-name)
            (set-visited-file-name new-name)
            (set-buffer-modified-p nil))))))
#+END_SRC

**** move-file関数 - ファイルを移動する
ファイルを指定したディレクトリに移動する

#+BEGIN_SRC emacs-lisp
  (defun move-file (file-path dest-dir-path)
    (catch 'my-err
      (if (not (file-exists-p file-path))
          (throw 'my-err "The Specified File does not exist!"))
      (if (file-exists-p dest-dir-path)
          (if (not (file-directory-p dest-dir-path))
              (throw 'my-err "The second argument should be a directory path!"))
        (if (yes-or-no-p (concat "\"" dest-dir-path "\" does not exist. do you create it? "))
            (mkdir dest-dir-path t)
          (throw 'my-err "Exit.")))
      (let* ((new-file-path (concat dest-dir-path
                                    (if (not (string-suffix-p "/" dest-dir-path)) "/" "")
                                    (file-basename file-path))))
        (rename-file file-path new-file-path t))))
#+END_SRC

**** tree-files関数 - ファイルの一覧を再帰的に取得する
引数のファイルパスを元にファイルリストを作成する。
引数がディレクトリパスの場合、中のファイルを再帰的にすべて取得する
引数がディレクトリ以外のパスの場合はそのファイルのみのリストになる
引数が存在しないパスの場合、nilを返す

#+BEGIN_SRC emacs-lisp
  (defun tree-files (path &rest options)
    "findコマンドのように再帰的なファイルの一覧を取得する。pathは起点となるディレクトリヘのパス。
  残りの引数ではオプションとしてファイルパスをフィルタリングする文字列を指定できる。
  :keywordに続く引数は文字列またはリストで、それらにマッチするファイルパスのみを戻り値に含める。"
    (let ((keyword (plist-get options :keyword)))
      (seq-filter
       (lambda (element)
         (if (not (null keyword))
             (if (listp keyword)
                 (seq-reduce
                  (lambda (result keyword-item)
                    (and result (string-match keyword-item element)))
                  keyword
                  t)
               (string-match keyword element))
           t))
       (if (file-directory-p path)
           (seq-reduce
            (lambda (result e)
              (append result (if (listp e) e (list e))))
            (seq-map
             (lambda (child-path)
               (if (file-directory-p child-path)
                   (tree-files child-path)
                 child-path))
             (seq-map
              (lambda (child-name)
                (concat path "/" child-name))
              (seq-filter
               (lambda (child-name)
                 (not (seq-contains-p '("." "..") child-name)))
               (directory-files path))))
            (list path))
         (if (file-exists-p path)
             (list path)
           '())))))
#+END_SRC

*** Lispユーティリティ系関数
**** has-value関数

#+BEGIN_SRC emacs-lisp
  (defun has-value (symbol) (not (null symbol)))
#+END_SRC

**** times関数
指定した回数分、関数を呼び出す。

#+BEGIN_SRC emacs-lisp
(defun times(num func)
  (let ((i 0))
    (while (< i num)
      (apply func)
      (setq i (+ i 1)))))
#+END_SRC

*** Emacsユーティリティ関数
**** 無名のバッファを作成する
#+BEGIN_SRC emacs-lisp
  (defun generate-buffer ()
    (interactive)
    (switch-to-buffer (make-temp-name "New Buffer ")))
#+END_SRC

**** バイトコンパイル系関数
***** byte-compile-file-in-dir関数
ディレクトリ内にある全ての.elファイルをバイトコンパイルする。

#+BEGIN_SRC emacs-lisp
  (defun byte-compile-file-in-dir (dir-path)
    "This function byte-compile all of emacs-lisp files that are contained in the directory which is passed as an argument of this function.
  Emacs-lisp files must have a extension '.el' in the file names."
    (let* ((file-list
            (seq-filter (lambda (a) (string-match "^[^.][^#].+\\.el$" a)) (directory-files dir-path))))
      (seq-do (lambda (file-name)
                (let* ((target-file (concat dir-path "/" file-name))
                       (compiled-file (concat target-file "c")))
                  (if (file-exists-p compiled-file)
                      (delete-file compiled-file))
                  (byte-compile-file target-file)))
              file-list)))
#+END_SRC

***** byte-compile-my-lib関数
設定ファイルをバイトコンパイルする

#+BEGIN_SRC emacs-lisp
  (defun byte-compile-my-lib()
    (cl-flet
        ((list-files-with-filter
          (lambda (dir-name arg-filter-func)
            (seq-filter
             (lambda (file-path)
               (file-exists-p file-path))
             (seq-map
              (lambda (name)
                (concat dir-name "/" name))
              (seq-filter arg-filter-func (directory-files dir-name)))))))
      (dolist (dir-path '("~/.emacs.d" "~/.emacs.d/lib-src"))
        (byte-compile-file-in-dir dir-path)
        (dolist (file-path (list-files-with-filter dir-path (lambda (name) (string-suffix-p ".elc" name))))
          (move-file file-path "~/.emacs.d/lib")))))
#+END_SRC

***** exit関数
設定ファイルをバイトコンパイルし、Emacsを終了する。

#+BEGIN_SRC emacs-lisp
  (defun exit ()
    "This command is used to exit emacs for preventing unwanted exit by some key combination."
    (interactive)
    (byte-compile-my-lib)
    (save-buffers-kill-terminal))
#+END_SRC

*** プログラミング言語対応関数
**** my-prettify-c-block-comment関数 - 整形されたCコメントを挿入
改行時にコメントの記号を補完する。
[[https://emacs.stackexchange.com/questions/14563/how-to-automatically-create-neat-c-comment-blocks-while-typing][参照URL]]

The below code works fine from my brief testing in a c-mode buffer:

After typing /*, hit M-j, the default binding for indent-new-comment-line (and the default binding for c-indent-new-comment-line in c-mode). If it is the first comment line the closing closing characters */ will be auto-inserted.
Hitting M-j more times with insert more comment lines with the * prefix. This is the in-built behavior of c-indent-new-comment-line/indent-new-comment-line functions. Check out the Multiple lines of comments documentation.
An extra nugget in the below code ensures that there is at least one space between the * on each comment line and the comment.

#+BEGIN_SRC emacs-lisp
  (defun prettify-c-block-comment (orig-fun &rest args)
    (let* ((is-first-comment-line (looking-back "/\\*\\s-*.*"))
           (is-following-comment-line (looking-back "^\\s-*\\*[^/]\\s-*.*"))
           (star-col-num (if (or is-first-comment-line is-following-comment-line)
                             (save-excursion
                               (re-search-backward "/\\*")
                               (+ 1 (current-column)))
                           -1)))
      (apply orig-fun args)
      (when is-first-comment-line
        (save-excursion
          (newline)
          (dotimes (cnt star-col-num)
            (insert " "))
          (insert "*/"))
        (move-to-column star-col-num) ; comment this line if using bsd style
        (insert " *") ; comment this line if using bsd style
        (when (not (looking-back " ")) ; Ensure one space between the asterisk and the comment
          (insert " ")))
      (when is-following-comment-line
        (move-to-column star-col-num)
        (insert "*")
        (when (not (looking-back " "))
          (insert " ")))))
#+END_SRC

アドバイスも作る。

#+BEGIN_SRC emacs-lisp
  ;;(advice-add 'c-indent-new-comment-line :around #'my-prettify-c-block-comment)
  ;;(advice-add 'electric-newline-and-maybe-indent :around #'my-prettify-c-block-comment)
  (advice-add 'tt-newline-and-indent :around #'prettify-c-block-comment)

  ;; (advice-remove 'c-indent-new-comment-line #'my-prettify-c-block-comment)
#+END_SRC


For instance, after evaluating the above code, I get the below on typing: /* M-j First comment line M-j Second comment line. The ▮ indicates the cursor location at the end of typing.
Testing offset comment block ..

With cursor after the semicolon, typing: /* M-j Test offset comment gives the below. The ▮ indicates the cursor location at the end of typing.

*** シェル系関数
**** mvn関数
シェルコマンドのmvnを実行する

#+BEGIN_SRC emacs-lisp
(defun mvn (arg-list)
  (shell-command (append (cons "mvn" arg-list))))
#+END_SRC

**** igrep関数 - 対話的にgrepを実行
grepコマンドを対話的に実行する関数。

#+BEGIN_SRC emacs-lisp
  (defun igrep(word directory)
    (interactive "s検索する言葉: \ns検索するディレクトリ: ")
    (grep (string-join nil
                       nil
                       " "
                       `("grep --color -nH --null -r -e"
                         ,(prin1-to-string word)
                         ,(prin1-to-string (expand-file-name directory))))))
#+END_SRC

*** 使ってない関数
ずいぶん前に作ったのや、必要がなくなった関数を書いとく。
**** send-this-buffer-to-server関数
ファイルの内容をサーバーに送信する。
tanakapoint (チュートリアルサイト用)

もう使ってない関数だけど、何かの参考になるかもしれないので取っておくか。

#+BEGIN_SRC emacs-lisp
  (defun send-this-buffer-to-server ()
    (interactive)
    (cl-flet
        ((send-request
           ;; request.elを使ってHTTPリクエストを送信する。現在のバッファをファイルとして送信する。
           (lambda (endpoint-url file-name)
             (request endpoint-url
               :type "POST"
               :files `(("fileToUpload" . (file-name :file ,(buffer-file-name))))
               :success (cl-function
                         (lambda (&key data &allow-other-keys)
                           (message "Successfully sent the contents of file '%s' to the server."
                                    (buffer-file-name))))
               :error (cl-function
                       (lambda (&rest args &key error-thrown &allow-other-keys)
                         (message "Got error: %S" error-thrown)))))))
      ;; ファイル名 (バッファ名) の先頭が連番である場合を対象にする。
      (when (string-match-p "^[0-9]+" (buffer-name))
        (cond
         ;; チュートリアル・サイトに送信する
         ((string-match-p "^/home/ta/tanakapoint/" (buffer-file-name))

          (let ((endpoint-url "http://localhost/filerecievesample2.php")
                (upload-name (replace-regexp-in-string "/home/ta/tanakapoint" "" (buffer-file-name))))
            (send-request endpoint-url upload-name)))

         ;; 日記サイトに送信する (未実装)
         ((string-match-p "^/home/ta/lodia/" (buffer-file-name))

          (let ((endpoint-url "http://blackcube.lodia.lo/files-register.php")
                (upload-name (replace-regexp-in-string "/home/ta/lodia" "" (buffer-file-name))))
            nil))

         ;; その他は何もしない
         (t nil)))))
#+END_SRC

**** save-and-send-if-modified関数
アドバイス関数。
ファイルを保存する時、更新されているか確認し、更新されている場合、send-this-buffer-to-server関数を実行する。advice-addでsave-bufferに付ける (init.el参照)。

#+BEGIN_SRC emacs-lisp
  (defun save-and-send-if-modified (orig-fun &rest args)
    "Save the current buffer with ORIG-FUN and ARGS.
  If the buffer was modified before saving, send its content to the server."
    (let ((was-modified (buffer-modified-p)))
      (apply orig-fun args)
      (when was-modified
        (send-this-buffer-to-server))))
#+END_SRC

** カスタムコマンド custom-commands
*** テキスト編集コマンド
**** 1文字消す (バックスペース) C-h
#+BEGIN_SRC emacs-lisp
  (defun delete-backward-1-char ()
    (interactive)
    (backward-delete-char-untabify 1))

  (global-set-key (kbd "C-h") 'delete-backward-1-char)
#+END_SRC
**** 前の単語を削除する M-h
#+BEGIN_SRC emacs-lisp
  (defun delete-backward-1-word ()
    (interactive)
    (delete-backward-word))
  
  (global-set-key (kbd "M-h") 'delete-backward-1-word)
#+END_SRC
**** 今の行を削除する C-k
#+BEGIN_SRC emacs-lisp
  (defun kill-current-line ()
    (interactive)
    (if (= 0 (current-column))
        (kill-line 1)
      (kill-line)))

  (global-set-key (kbd "C-k") 'kill-current-line)
#+END_SRC
**** 文字列を置換する C-c f
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c f") 'replace-string)
#+END_SRC
**** 文字列を正規表現で置換する C-c r
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c r") 'replace-regexp)
#+END_SRC
**** 後ろの行を結合する M-j
#+BEGIN_SRC emacs-lisp
  (defun join-next-line ()  
    (interactive)
    (move-end-of-line nil)
    (forward-char)
    (delete-indentation))

  (global-set-key (kbd "M-j") 'join-next-line)
#+END_SRC
**** バッファ名をバッファに挿入する C-c n
#+BEGIN_SRC emacs-lisp
  (defun put-buffer-name()
    (interactive)
    (if (not (null (buffer-file-name)))
        (skk-insert-str (replace-regexp-in-string
                         "^.*/" ""
                         (replace-regexp-in-string
                          "\.[a-zA-Z0-9]+$"
                          ""
                          (buffer-file-name))))))
  
  (global-set-key (kbd "C-c n") 'put-buffer-name)
#+END_SRC
**** 絵文字を挿入する C-c C-r
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c C-r") 'revert-buffer)
#+END_SRC
**** ファイルを保存した状態に戻す
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c C-r") 'revert-buffer)
#+END_SRC
*** カーソル移動コマンド
**** 次の単語の先頭に進む M-f
#+BEGIN_SRC emacs-lisp
  (defun skip-word-forward ()
    (interactive)
    (let ((save-point (point)))
      (skip-chars-forward "[:blank:][:cntrl:][:punct:]")
      (when (= (point) save-point)
        (forward-word)
        (skip-chars-forward "[:blank:][:cntrl:][:punct:]"))))
  
  (global-set-key (kbd "M-f") 'skip-word-forward)
#+END_SRC
**** 単語の最後に進む M-e
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-e") 'forward-word)
#+END_SRC

**** 5行下にカーソルを移動する C-c C-n
#+BEGIN_SRC emacs-lisp
  (defun move-5-lines-down ()
    (interactive)
    (next-line 5))

  (global-set-key (kbd "C-c C-n") 'move-5-lines-down)
#+END_SRC
**** 5行上にカーソルを移動する C-c C-p
#+BEGIN_SRC emacs-lisp
  (defun move-5-lines-up ()
    (interactive)
    (previous-line 5))
  
  (global-set-key (kbd "C-c C-p") 'move-5-lines-up)
#+END_SRC
**** 次のウィンドウに移動 C-}
#+BEGIN_SRC emacs-lisp
  (defun move-to-next-window ()
    (interactive)
    (other-window 1))

  (global-set-key (kbd "C-}") 'move-to-next-window)
#+END_SRC
**** 前のウィンドウに移動 C-{
#+BEGIN_SRC emacs-lisp
  (defun move-to-previous-window ()
    (interactive)
    (other-window -1))

  (global-set-key (kbd "C-{") 'move-to-previous-window)
#+END_SRC
**** 前の段落に移動する C-S-p
#+BEGIN_SRC emacs-lisp
  (defun move-backward-1-paragraph ()
    (interactive)
    (let ((save-point (point)))
       (backward-paragraph 1)
       (skip-chars-forward "[:blank:][:cntrl:]")
       (when (= (point) save-point)
         (backward-paragraph 2)
         (skip-chars-forward "[:blank:][:cntrl:]"))))

  (global-set-key (kbd "C-S-p") 'move-backward-1-paragraph)
  (global-set-key (kbd "M-[") 'backward-paragraph)
#+END_SRC
**** 次の段落に移動する C-S-n
#+BEGIN_SRC emacs-lisp
  (defun move-forward-1-paragraph ()
    (interactive)
    (forward-paragraph 1)
    (skip-chars-forward "[:blank:][:cntrl:]"))

  (global-set-key (kbd "C-S-n") 'move-forward-1-paragraph)
  (global-set-key (kbd "M-]") 'forward-paragraph)
#+END_SRC
**** 指定の行に移動する C-:
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-:") 'goto-line)
#+END_SRC
*** モード設定コマンド
**** SKKモード
#+BEGIN_SRC emacs-lisp
  (defun skk-insert-str-interactive ()
    (interactive)
    (skk-insert-str (buffer-name)))

  (global-set-key (kbd "C-x C-j") 'skk-mode)
  (global-set-key (kbd "C-x j") 'skk-auto-fill-mode)
  (global-set-key (kbd "C-x t") 'skk-tutorial)
  (global-set-key (kbd "C-c C-c f") 'skk-insert-str-interactive)
#+END_SRC
**** 入力メソッドを切り換える
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<zenkaku-hankaku>") 'toggle-input-method)
#+END_SRC
**** 組み込みのIMEを無効化する
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-\\") nil)
  (global-set-key (kbd "C-_") nil)
#+END_SRC
*** 表示コントロールコマンド
**** 指定の行数分、上にスクロールする
#+BEGIN_SRC emacs-lisp
  (defun scroll-up-an-amount ()
    (interactive)
    (scroll-up scroll-amount-at-once))

  (global-set-key (kbd "M-n") 'scroll-up-an-amount)
  (global-set-key (kbd "<mouse-5>") 'scroll-up-an-amount)
#+END_SRC
**** 指定の行数分、下にスクロールする
#+BEGIN_SRC emacs-lisp
  (defun scroll-down-an-amount ()
    (interactive)
    (scroll-down scroll-amount-at-once))

  (global-set-key (kbd "M-p") 'scroll-down-an-amount)
  (global-set-key (kbd "<mouse-4>") 'scroll-down-an-amount)
#+END_SRC
**** 新しいフレームを作成する
#+BEGIN_SRC emacs-lisp
  (defun create-new-frame-interactive()
    (interactive)
    (create-new-frame))
  
  (global-set-key (kbd "C-x 5 2") 'create-new-frame-interactive)
#+END_SRC
*** その他、よくわからないキーバインドがある
#+BEGIN_SRC emacs-lisp
  ;;(global-set-key (kbd "C-x C-z") nil)
  ;;(global-set-key (kbd "C-x C-c") nil)
#+END_SRC
*** 最近開いたファイル
recentlyをインストールする必要がある
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-r") 'recently-show)
#+END_SRC
*** 保存する時に、更新時刻が勝手に変更されて保存できない場合への対処として、強制保存をする

#+BEGIN_SRC emacs-lisp

  (defun my-reset-file-modtime ()
    "保存後にファイルのmodtimeをリセットして、Emacsに『変わってない』と思わせる。"
    (when buffer-file-name
      (clear-visited-file-modtime)))

  (add-hook 'after-save-hook 'my-reset-file-modtime)

#+END_SRC

#+RESULTS:

** カスタムマクロ custom-macros
*** ifuncマクロ - 対話的lambdaを生成する
マクロを定義する。cmdは即席のコマンドを定義する。キーバインド設定で使う。
使用例:
(global-set-key (kbd "C-x w n") (cmd (other-window 1)))
(global-set-key (kbd "C-x w p") (cmd (other-window -1)))

#+BEGIN_SRC emacs-lisp
(defmacro ifunc (&rest body)
  (append (list 'lambda '() (list 'interactive)) body))
#+END_SRC

** カスタム変数 custom-variables
*** スクロール幅の設定

#+BEGIN_SRC emacs-lisp
(defvar scroll-amount-at-once 3 "M-nやM-pで一度にスクロールする行数")
#+END_SRC

** 変数の設定変更 custom-settings

*** デフォルト・ディレクトリの設定

#+BEGIN_SRC emacs-lisp
;; デフォルトのディレクトリを設定する
;;(setq default-directory "C:/Users/aharo/")
#+END_SRC

*** 警告音の停止

#+BEGIN_SRC emacs-lisp
  (setq visible-bell 1)
#+END_SRC

*** カーソル・タイプ
カーソルを2ピクセルの縦棒にする

#+BEGIN_SRC emacs-lisp
  (setq-default cursor-type '(bar . 2))
#+END_SRC

*** バックアップファイルの無効化
ファイル保存時にバックアップファイルを作成しない設定

#+BEGIN_SRC emacs-lisp
  ;;(setq make-backup-files nil)
  ;;(setq auto-save-default nil)
  ;;(setq create-lockfiles nil)
#+END_SRC

*** バックアップファイルの設定 (ディレクトリ、履歴管理)

この設定をすると、好きな場所にバックアップファイルを自動で作成・保存できる。
更に、履歴保存もできる。

#+BEGIN_SRC emacs-lisp
  (setq backup-by-copying t      ; don't clobber symlinks
        backup-directory-alist
        '(("." . "~/.emacs.d/backup-files/"))    ; don't litter my fs tree
        delete-old-versions t
        kept-new-versions 6
        kept-old-versions 2
        version-control t)       ; use versioned backups
#+END_SRC

*** インデントをタブに変換しない
インデントをタブに自動変換しないように設定する

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

*** 初期表示画面を変更
起動時にスプラッシュ画面を表示しない設定にする

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
#+END_SRC

*** スクラッチ・バッファの初期表示を変更

#+BEGIN_SRC emacs-lisp
  (setq initial-scratch-message nil)
#+END_SRC

元々のメッセージはこうだった↓。

#+BEGIN_SRC emacs-lisp
  ;; This buffer is for text that is not saved, and for Lisp evaluation.
  ;; To create a file, visit it with find-file and enter text in its buffer.
  
#+END_SRC

*** サーバーモードの設定 (実行しない)

#+BEGIN_SRC emacs-lisp
;;(server-mode)
#+END_SRC

*** ファイル保存時の設定

+BEGIN_SRC emacs-lisp
  ;; 保存時の二重確認を無効にする
  (setq file-precious-flag nil)
  ;; リモートファイルのロックを無効にする
  (setq remote-file-name-inhibit-locks t)
  ;; セーブメッセージ抑制
  (setq save-silently t)
  ;; タイマーによるオートセーブを無効
  (setq auto-save-timeout 0)
  ;; 存在しないファイルへの保存確認を無効にする
  (setq confirm-nonexistent-file-or-buffer nil)
  ;; 保存時に聞かない
  (setq buffer-save-without-query t)
  ;; バッファ保存の警告無効
  (setq save-some-buffers-action-alist nil)

  (setq revert-without-query '(".*"))

  (setq require-final-newline nil)

  ;; ファイルが外部で更新されたかチェックしない
  (setq auto-revert-verbose nil)
  (setq auto-revert-interval 10)
  ;; ファイルが更新されても自動で読み直す
  (global-auto-revert-mode t)
#+END_SRC

** カスタム・モード custom-modes
カスタム・モードの作り方は難しいんだけど、ジェネリック・モードならすぐに作れた。
それを利用してValaのモードを作ってみた。

*** Valaモード (使わない)
tt-vala-modeを作成する。

tt-vala-mode.el --- Major mode for editing Vala code

Copyright (C) 2020 Takayuki Tanaka

Author: Takayuki Tanaka
Maintainer: Takayuki Tanaka <aharotias2@gmail.com>
URL: https://github.com/aharotias/tt-vala-mode
Keywords: languages vala
Version: 0.1
Package-Requires: ((emacs "24.3"))
License: GPL-3.0-or-later

Valaモードに使う色々な関数 (もう内容をあまり思い出せない‥‥‥)

+begin_src emacs-lisp
  (defun not-used-tt-vala-mode-1()
    (setq tt-indent-offset 4)

    (defadvice indent-rigidly (after deactivate-mark-nil activate)
      (setq deactivate-mark nil))

    (defun tt-indent-region (offset)
      (interactive)
      (let ((p1 (mark))
            (p2 (point)))
        (indent-rigidly (min p1 p2) (max p1 p2) offset)))

    (defun tt-indent-right (offset)
      (interactive)
      (let* ((cc (current-column)) (i (+ cc 1)))
        (while (not (= (% i offset) 0))
          (setq i (+ i 1)))
        (indent-to i)))

    (defun tt-indent-left (offset)
      (interactive)
      (let ((save-column (current-column)) (num-killed-chars 0))
        (beginning-of-line)
        (while (and (> offset 0) (= (char-after (point)) 32))
          (delete-char 1)
          (setq offset (- offset 1))
          (setq num-killed-chars (+ num-killed-chars 1)))
        (move-to-column (- save-column num-killed-chars)))

    (defun tt-indent (offset)
      (interactive)
      (if mark-active
          (tt-indent-region offset)
        (if (> offset 0)
            (tt-indent-right offset)
          (tt-indent-left (- 0 offset))))

    (defun tt-newline-and-indent ()
      (interactive)
      (if (= 0 (- (point) (line-number-at-pos)))
          (newline)
        (let ((auto-indent-offset (let ((before-char (char-before (point))))
                                    (if (and (not (null before-char)) (or (= before-char 123) (= before-char 40)))
                                        tt-indent-offset
                                      0))))
          (newline)
          (indent-relative-maybe)
          (if (> auto-indent-offset 0)
              (tt-indent auto-indent-offset))))
    )
+end_src


Valaのコメント記号

+begin_src emacs-lisp  
  (defun not-used-tt-vala-mode-2()
    (setq tt-vala-comment-list
          '("//" ("/*" . "*/")))
+end_src


Valaの予約語一覧

+begin_src emacs-lisp
  (defun not-used-tt-vala-mode-3()
    (setq tt-vala-keyword-list
          '("if" "else" "switch" "case" "default" "do" "while" "for" "foreach" "in" "break"
            "continue" "return" "try" "catch" "finally" "throw" "lock" "class" "interface"
            "struct" "enum" "delegate" "errordomain" "const" "weak" "unowned" "dynamic"
            "callback" "begin" "end" "abstract" "virtual" "override" "signal" "extern"
            "static" "async" "inline" "new" "public" "private" "protected" "internal" "out"
            "ref" "throws" "requires" "ensures" "namespace" "using" "as" "is" "in" "new"
            "delete" "sizeof" "typeof" "this" "base" "get" "set" "construct" "default"
            "value" "connect" "construct" "static construct" "class construct" "var" "yield"
            "global" "owned" "with"))
    )
+end_src


色付けのための正規表現のリスト

+begin_src emacs-lisp
  (defun not-used-tt-vala-mode-4()
    (setq tt-vala-face-list
          `(("\"\"\".*\"\"\"" . font-lock-string-face)
            ("\".*\"" . font-lock-string-face)
            ("'[^']*'" . font-lock-string-face)
            ("[][+-/*%=^~|{}()!&><;:,.?/@$]" . font-lock-builtin-face)
            (,(regexp-opt '("true" "false" "null" "void" "int" "uint"
                            "long" "string" "double" "int8" "uint8"
                            "int16" "uint16" "int32" "uint32" "int64"
                            "uint64" "float" "bool" "char" "uchar")
                          'symbols)
             . font-lock-builtin-face)
            ("\\<[@A-Z_][A-Z0-9_]+\\>" . font-lock-constant-face)
            ("\\<[0-9]+\\>" . font-lock-constant-face)
            ("\\<[A-Z][A-Za-z0-9_]+\\>" . font-lock-type-face)))
    )
+end_src

+begin_src emacs-lisp
  (defun not-used-tt-vala-mode-5()
    (defun tt-vala-mode-setup-func()
      (interactive)
      (local-set-key (kbd "X-i") 'tt-indent-left)
      (local-set-key (kbd "C-i") (lambda() (interactive) (tt-indent tt-indent-offset)))
      )
    )
+end_src

ジェネリック・モードとしてValaモードを作成する

+begin_src emacs-lisp
  (defun not-used-tt-vala-mode-6()
    (define-generic-mode tt-vala-mode
      tt-vala-comment-list
      tt-vala-keyword-list
      tt-vala-face-list
      '("\\.vala\\'" "\\.vapi\\'")
      (list #'tt-vala-mode-setup-func)
      ;; &optional docstring
      "This is a major mode for editing vala programming language")
    )
+end_src

*** Valaモード (2)
改良版を作った。
ChatGPTにベースを作らせてちょこちょこ修正。

#+BEGIN_SRC emacs-lisp
  (require 'my-vala-mode)
#+END_SRC

** モードごとの設定 mode-settings
*** DDSKKの設定
**** 初期設定
#+BEGIN_SRC emacs-lisp
  (require 'ddskk-autoloads)
  (setq skk-large-jisyo "~/.emacs.d/SKK-JISYO.L")
#+END_SRC

*** helmモードの設定 (不使用)
BEGIN_SRC emacs-lisp
 ;; Helmの設定
  (require 'helm)
  ;;(require 'helm-config)
  (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
  (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action)
  (define-key helm-map (kbd "C-z") 'helm-select-action)

  (when (executable-find "curl")
    (setq helm-google-suggest-use-curl-p t))

  (setq helm-split-window-in-side-p t
        helm-move-to-line-cycle-in-source t
        helm-ff-search-library-in-sexp t
        helm-scroll-amount 8
        helm-ff-file-name-history-use-recentf t
        helm-echo-input-in-header-line t
        helm-autoresize-min-height 20
        helm-autoresize-max-height 60
        helm-M-x-fuzzy-match t)

  (defun spacemacs//helm-hide-minibuffer-maybe ()
    "Hide minibuffer in Helm session if we use the header line as input field."
    (when (with-helm-buffer helm-echo-input-in-header-line)
      (let ((ov (make-overlay (point-min) (point-max) nil nil t)))
        (overlay-put ov 'window (selected-window))
        (overlay-put ov 'face
                     (let ((bg-color (face-background 'default nil)))))
        (setq-local cursor-type nil))))

  (add-hook 'helm-minibuffer-set-up-hook
            'spacemacs//helm-hide-minibuffer-maybe)
  (helm-autoresize-mode 1)
  (helm-mode 1)

END_SRC
*** shellモードの設定
**** フックの設定
#+BEGIN_SRC emacs-lisp
  (add-hook 'shell-script-mode-hook
            (lambda nil
              (toggle-truncate-lines 1)
              (display-line-numbers-mode 1)))
#+END_SRC

*** orgモードの設定
**** 見出しを1階層ずつ開く関数を設定 (C-<tab>で実行)
OrgModeの時、見出しの上で「C-<tab>」キーを押すと子見出しを1階層ずつ開いていく機能を実装。
ChatGPTに作らせたコードをベースにちょこちょこ修正して作成。

***** カスタム変数
#+BEGIN_SRC emacs-lisp
  (defvar my-org-cycle-last-pos nil)
  (defvar my-org-cycle-last-depth 0)
#+END_SRC

***** 見出しを再帰的に開く関数
#+BEGIN_SRC emacs-lisp
  (defun my-org-show-children-recursive (depth)
    "現在の見出しから、指定されたDEPTH階層まで子見出しを再帰的に表示する。"
    (when (org-at-heading-p)
      ;;(org-show-entry)
      (when (> depth 0)
        (save-excursion
          (org-show-children 0)
          (let ((end (save-excursion (org-end-of-subtree t t))))
            (org-next-visible-heading 1)
            (while (< (point) end)
              (when (org-at-heading-p)
                (my-org-show-children-recursive (1- depth))
                (let ((my-save-point (point)))
                  (org-forward-heading-same-level 1)
                  (when (= my-save-point (point))
                    (outline-up-heading 1)
                    (org-forward-heading-same-level 1))))))))))
#+END_SRC

***** コマンド関数。起動判定とか。
#+BEGIN_SRC emacs-lisp
  (defun my-org-cycle-stepwise ()
    "現在の見出しから、1階層ずつ子要素を展開していく。別の見出しに移動するとリセット。"
    (interactive)
    (when (org-at-heading-p)
      (let ((pos (point)))
        (if (eq pos my-org-cycle-last-pos)
            (setq my-org-cycle-last-depth (1+ my-org-cycle-last-depth))
          (progn (setq my-org-cycle-last-pos pos)
                 (setq my-org-cycle-last-depth 1))))
      (my-org-show-children-recursive my-org-cycle-last-depth)))

#+END_SRC

***** OrgModeのキーバインディングに登録する
#+BEGIN_SRC emacs-lisp
  (define-key org-mode-map (kbd "C-<tab>") 'my-org-cycle-stepwise)
#+END_SRC

***** カーソルを移動したら状態をリセットしてまた1から開くようにする
#+BEGIN_SRC emacs-lisp
(defun my-org-cycle-reset-on-move ()
  "カーソル移動したら cycle 状態をリセットする。"
  (when (and (eq major-mode 'org-mode)
             (not (eq (point) my-org-cycle-last-pos)))
    (setq my-org-cycle-last-pos nil)
    (setq my-org-cycle-last-depth 0)))

(defun my-org-cycle-setup-reset-hook ()
  "org-mode用にpost-command-hookを設定"
  (add-hook 'post-command-hook #'my-org-cycle-reset-on-move nil t))

(add-hook 'org-mode-hook #'my-org-cycle-setup-reset-hook)

#+END_SRC

**** 画像ファイルをドラッグ&ドロップしてパスを挿入する
ChatGPTに頼んで作らせたのものをベースに作ってるけど、うまいことカーソル位置に画像パスが挿入されてくれない不具合がある。

***** OrgModeファイルの見出しをパスに変換する関数
#+BEGIN_SRC emacs-lisp
  (defun my-org-heading-path-sanitized ()
    "現在のorg-mode見出し階層を取得して、スラッシュなどをパス用にサニタイズする。"
    (when (derived-mode-p 'org-mode)
      (let ((path nil))
        (save-excursion
          (while (org-up-heading-safe)
            (push (my-sanitize-path-component (org-get-heading t t t t)) path))
          (push (my-sanitize-path-component (org-get-heading t t t t)) path))
        path)))

  (defun my-sanitize-path-component (s)
    "パス名に使えない文字（例：/）を安全な文字に置き換える。"
    (replace-regexp-in-string "/" "-" s))

#+END_SRC

***** 本体関数
orgモードのキーバインディングには上の方で定義しているifuncマクロを使用している。

#+BEGIN_SRC emacs-lisp
  (defun my-org-dnd-insert-image-under-heading (uri action)
    "Orgバッファで画像ファイルをドロップしたときに、見出しに対応したフォルダにコピーし、リンクを挿入する。"
    (let ((decoded (dnd-get-local-file-name uri t)))
      (when (and decoded (file-exists-p decoded))
        (let* ((ext (downcase (or (file-name-extension decoded) ""))))
          (when (member ext '("png" "jpg" "jpeg" "gif" "svg" "webp"))
            ;; 見出しパスを取得 → スラッシュを安全な文字に変換
            (let ((heading-path (my-org-heading-path-sanitized)))
              (when heading-path
                (let* ((target-dir (expand-file-name (mapconcat #'identity heading-path "/") default-directory)))
                  (unless (file-directory-p target-dir)
                    (make-directory target-dir t))
                  ;; リネーム：img_YYYYMMDD_HHMMSS.ext
                  (let* ((timestamp (format-time-string "%Y%m%d_%H%M%S"))
                         (new-name (format "img_%s.%s" timestamp ext))
                         (target-path (expand-file-name new-name target-dir)))
                    (copy-file decoded target-path t)
                    (let ((rel-path (file-relative-name target-path default-directory)))
                      (insert (format "[[file:%s]]" rel-path))
                      t))))))))))

#+END_SRC

***** ドラッグ&ドロップのフックに登録する
#+BEGIN_SRC emacs-lisp
  (defun enable-my-org-dnd-insert-image ()
    "Orgモードで画像ドラッグ＆ドロップを有効にする。"
    (interactive)
    (when (derived-mode-p 'org-mode)
      (add-hook 'dnd-protocol-alist
                '("^file:" . my-org-dnd-insert-image-under-heading)
                nil t)))
#+END_SRC

**** フックの設定
#+BEGIN_SRC emacs-lisp
  ;; org-modeの設定

  (setq org-hide-leading-stars t)
  (setq org-startup-indented t)

  (add-hook 'org-mode-hook
            (lambda nil
              (font-lock-mode t)
              (display-line-numbers-mode 1)
              (enable-my-org-dnd-insert-image)
              (local-set-key (kbd "C-M-f") (ifunc (org-shiftmetaright)))
              (local-set-key (kbd "C-M-b") (ifunc (org-shiftmetaleft)))
              (local-set-key (kbd "C-S-f") (ifunc (org-shiftright)))
              (local-set-key (kbd "C-S-b") (ifunc (org-shiftleft)))
              (local-set-key (kbd "C-c a") (ifunc (org-agenda)))
              (local-set-key (kbd "C-M-o") (ifunc (org-insert-heading-after-current)))
              ;;(local-set-key (kbd "C-c e") (ifunc (emoji-cheat-sheet-plus-insert)))
              (local-set-key (kbd "C-c h") (ifunc (org-toggle-heading)))
              (local-set-key (kbd "C-c i") (ifunc (org-toggle-item)))
              ;;(local-set-key (kbd "C-c C-x e") (ifunc (emoji-cheat-sheet-plus-display-mode)))
              (local-set-key (kbd "C-o") (ifunc (org-end-of-line)
                                                (org-return-indent)))
              (variable-pitch-mode)
              (visual-line-mode)
              (emoji-cheat-sheet-plus-display-mode)))
#+END_SRC

**** org-insert-block
org-modeで使うスニペットのような関数

#+BEGIN_SRC emacs-lisp
  (defun org-insert-block(language-name)
    (interactive "slanguage: ")
    (insert "#+BEGIN_SRC ")
    (insert language-name)
    (newline)
    (newline)
    (insert "#+END_SRC")
    (previous-line 1))
#+END_SRC

*** CSVモード
**** フックの設定
#+BEGIN_SRC emacs-lisp
  (add-hook 'csv-mode-hook
            (lambda nil
              (display-line-numbers-mode 1)
              (local-set-key (kbd "M-a") (ifunc (csv-align-fields)))
              (local-set-key (kbd "M-u") (ifunc (csv-unalign-fields)))
              (local-set-key (kbd "M-f") (ifunc (csv-forward-field)))
              (local-set-key (kbd "M-b") (ifunc (csv-backward-field)))))
#+END_SRC

*** YAMLモード
**** フックの設定
#+BEGIN_SRC emacs-lisp
(add-hook 'yaml-mode
          (lambda ()
            (display-line-numbers-mode 1)
            (variable-pitch-mode 0)))
#+END_SRC

*** Cモード
**** フックの設定
#+BEGIN_SRC emacs-lisp
  (add-hook 'c-mode-hook
            (lambda ()
              (display-line-numbers-mode 1)
              (setq c-basic-offset 4)
              (setq tab-width 4)
              (setq indent-tabs-mode nil)
              (local-set-key (kbd "C-c q") 'electric-quote-local-mode)
              (toggle-truncate-lines)))
#+END_SRC

*** Emacs LISPモード
**** フックの設定
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook
            (lambda ()
              (display-line-numbers-mode 1)
              (local-set-key (kbd "<f5>") 'eval-buffer)))
#+END_SRC

*** Makeモード
**** フックの設定
#+BEGIN_SRC emacs-lisp
  (add-hook 'make-mode-hook
            (lambda ()
              (display-line-numbers-mode 1)
              (local-set-key (kbd "<f5>") 'compile)))
#+END_SRC

*** Markdownモード
**** 関数
***** put-buffer-name-in-markdown-metadata関数

#+BEGIN_SRC emacs-lisp
(defun put-buffer-name-in-markdown-metadata ()
  (interactive)
  (when (string= major-mode "markdown-mode")
    (beginning-of-buffer)
    (insert "---\n")
    (insert "title: ") (put-buffer-name) (insert "\n")
    (insert (format "date: %s\n" (string-trim-right (shell-command-to-string "date +%Y-%m-%d"))))
    (insert "---\n")))
#+END_SRC

***** markdown-ex-append-linebreaks-multiline関数
マークダウンモードで、各行の行末にスペース二つを追加する。
選択された複数行に渡って適用する。

#+BEGIN_SRC emacs-lisp
(defun markdown-ex-append-linebreaks-multiline ()
  (interactive)
  ;; markdown-modeの場合のみ処理を行う。
  (when (string= major-mode "markdown-mode")
    ;; 領域内の全ての行末にスペースを2つ追加する
    (replace-regexp "$" "  " nil (point) (mark))))
#+END_SRC

***** markdown-append-linebreak関数
マークダウンモードで、各行の行末にスペース二つを追加する。
追加した後、次の行に移動する。
すでに行末にスペース2つがある場合、それを削除する。
削除した後は、次の行に移動しない。

#+BEGIN_SRC emacs-lisp
(defun markdown-ex-append-linebreak()
  (interactive)
  ;; markdown-modeの場合のみ処理を行う。
  (when (string= major-mode "markdown-mode")
    (let ((previous-column (current-column))) ;; 現在のカラム位置を保存する
      ;; 行末に移動する
      (end-of-line)
      (if (> (current-column) 0)
          ;; 現在の行が空行でない場合
          (let ((last-two-characters (buffer-substring-no-properties (- (point) 2) (point))))
            (if (string= "  " last-two-characters)
                ;; 行末にスペースが2つある場合
                (progn
                  ;; 行末のスペースを削除する
                  (backward-delete-char 2)
                  ;; 保存したカラム位置に移動する (カーソルが移動していないように見えるようにする)
                  (move-to-column previous-column))
              ;; 行末にスペースが2つない場合
              (progn
                ;; 行末にスペースを2つ追加
                (insert "  ")
                ;; 次の行に進む
                (if (= (forward-line 1) 0)
                    ;; 次の行がある場合
                    (progn
                      ;; 行末に移動
                      (end-of-line)
                      (if (< previous-column (current-column))
                          ;; 保存したカラム位置に移動する (真下に移動したように見えるようにする)
                          (move-to-column previous-column)))
                  ;; 次の行がない場合、改行のみ行う
                  (newline)))))
        ;; 現在の行が空行の場合1行進む
        (if (> (forward-line 1) 0)
            ;; 最後の行の場合、改行 (行を追加) する
            (newline))))))
#+END_SRC

***** markdown-ex-append-linebreak-and-open関数

#+BEGIN_SRC emacs-lisp
  (defun markdown-ex-append-linebreak-and-open ()
    (interactive)
    (when (string= major-mode "markdown-mode")
      (markdown-ex-append-linebreak)
      (beginning-of-line)
      (open-line 1)))
#+END_SRC

***** markdown-ex-add-category関数

#+BEGIN_SRC emacs-lisp
  (defun markdown-ex-add-category (new-category-name)
    (interactive "Mcategory name: ")
    (point-to-register ?x)
    (beginning-of-buffer)
    (insert "---\nカテゴリ:" new-category-name "\n---\n"))
#+END_SRC

***** my-adjoin-to-list-or-symbol関数
可変幅フォントを使う為の設定。[[https://yoo2080.wordpress.com/2013/05/30/monospace-font-in-tables-and-source-code-blocks-in-org-mode-proportional-font-in-other-parts/][このURL]]を参照
cl-adjoinは追加したい要素がリストに含まれていない場合のみ、その先頭に追加する関数。
この関数はリストがリストでない場合にはそれをリストにしてから実行するようになっている。

#+BEGIN_SRC emacs-lisp
  (defun my-adjoin-to-list-or-symbol (element list-or-symbol)
    (let ((list (if (not (listp list-or-symbol))
                    (list list-or-symbol)
                  list-or-symbol)))
      (require 'cl-lib)
      (cl-adjoin element list)))
#+END_SRC

***** my-markdown-dnd-copy-image-to-img-dir関数

Markdownファイルに画像ファイルをドラッグ&ドロップした時に、![img](画像ファイルの相対パス)を挿入する
更に、Markdownファイルと同じディレクトリを作り、そこにファイル名を日付フォーマットした上でコピーする。

#+BEGIN_SRC emacs-lisp
  (defun my-markdown-dnd-copy-image-to-img-dir (uri action)
    "画像を ./img にコピーして、Markdownリンクを挿入する。"
    (let ((decoded (dnd-get-local-file-name uri t)))
      (when (and decoded (file-exists-p decoded))
        (let* ((img-dir "./img")
               (ext (downcase (or (file-name-extension decoded) ""))))
          (when (member ext '("png" "jpg" "jpeg" "gif" "svg" "webp"))
            (unless (file-directory-p img-dir)
              (make-directory img-dir))  ; ./img がなければ作る
            ;; リネーム：img_YYYYMMDD_HHMMSS.ext
            (let* ((timestamp (format-time-string "%Y%m%d_%H%M%S"))
                   (new-name (format "img_%s.%s" timestamp ext))
                   (new-path (expand-file-name new-name img-dir)))
              (copy-file decoded new-path t) ; 上書きOKでコピー
              (let ((rel-path (file-relative-name new-path default-directory)))
                (insert (format "![img](%s)" rel-path))
                t)))))))
  
  (defun enable-my-markdown-dnd-copy ()
    "MarkdownモードでD&D画像を ./img にコピー＆挿入する設定を有効にする。"
    (interactive)
    (when (derived-mode-p 'markdown-mode)
      (add-hook 'dnd-protocol-alist
                '("^file:" . my-markdown-dnd-copy-image-to-img-dir)
                nil t)))
#+END_SRC

**** Markdownの設定
***** テーブルとコードのフォントを等幅にする設定
理屈はよくわからないが、この設定をすることでテーブルとコードのフォントのみ等幅になる。

#+BEGIN_SRC emacs-lisp
  (eval-after-load "markdown-mode"
    '(mapc
      (lambda (face)
        (set-face-attribute
         face nil
         :inherit
         (my-adjoin-to-list-or-symbol
          'fixed-pitch
          (face-attribute face :inherit))))
      (list 'markdown-pre-face 'markdown-inline-code-face 'markdown-table-face)))
#+END_SRC

Markdownモードの設定を行なう。

***** プレビューモードの自動読み込み
#+BEGIN_SRC emacs-lisp
  (autoload 'markdown-preview-mode "markdown-preview-mode.el" t)
#+END_SRC

***** フックの設定
#+BEGIN_SRC emacs_lisp
  (add-hook 'markdown-mode-hook
            (lambda nil
              (display-line-numbers-mode)
              ;;(auto-fill-mode t)
              (setq fill-column 100)
              (variable-pitch-mode 1) ;; デフォルトのフォントを可変幅フォントにする
              (electric-quote-local-mode 1)
              (visual-line-mode 1)
              (enable-my-markdown-dnd-copy) ;;画像ファイルのドラッグ&ドロップを有効にする
              ;;(skk-mode 1)
              (local-set-key (kbd "C-c n") 'put-buffer-name-in-markdown-metadata)
              (local-set-key (kbd "C-c C-c k") 'markdown-ex-add-category)
              (local-set-key (kbd "C-c q") 'electric-quote-local-mode)
              (local-set-key (kbd "C-c C-m") 'markdown-ex-append-linebreaks-multiline)
              (local-set-key (kbd "M-m") 'markdown-ex-append-linebreak)
              (local-set-key (kbd "M-n") (ifunc (scroll-up scroll-amount-at-once)))
              (local-set-key (kbd "M-p") (ifunc (scroll-down scroll-amount-at-once)))
              (local-set-key (kbd "C-c m") (ifunc (markdown-ex-append-linebreak)
                                                  (beginning-of-line)
                                                  (open-line 1)))))

#+END_SRC

*** Webモードの設定
**** フックの設定
#+BEGIN_SRC emacs-lisp
  (add-hook 'web-mode-hook
            (lambda ()
              (display-line-numbers-mode 1)
              (setq web-mode-markup-indent-offset 2)
              (local-set-key (kbd "<f5>") 'web-mode)))
#+END_SRC

*** nXMLモードの設定
#+BEGIN_SRC emacs-lisp
;; auto-complete-nxmlの設定
;; Keystroke for popup help about something at point.
(setq auto-complete-nxml-popup-help-key "C-,")
;; Keystroke for toggle on/off automatic completion.
(setq auto-complete-nxml-toggle-automatic-key "C-c C-t")
;; If you want to start completion manually from the beginning
(setq auto-complete-nxml-automatic-p nil)
#+END_SRC

*** Javaモード
**** フックの設定
#+BEGIN_SRC emacs-lisp
  (add-hook 'java-mode-hook
            (lambda ()
              (setq c-default-style "java")
              (c-set-offset 'arglist-intro '+)
              (c-set-offset 'arglist-close '0)
              (c-set-offset 'case-label '+)
              (display-line-numbers-mode 1)
              (local-set-key-list
               '(("<f5>" (mvn "package"))))))
#+END_SRC

*** JavaScriptモード

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.jsx?\\'" . js-jsx-mode))
  (add-hook 'js-jsx-mode-hook
            (lambda ()
              (display-line-numbers-mode 1)))
#+END_SRC

*** テキスト・モード

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.te?xt\\'" . text-mode))
  (add-hook 'text-mode-hook
            (lambda ()
              (display-line-numbers-mode)
              (if (not (string-suffix-p ".log" (buffer-name)))
                  (variable-pitch-mode 1))))
#+END_SRC

*** Viewモード

#+BEGIN_SRC emacs-lisp
  (add-hook 'view-mode-hook
            (lambda ()
              (display-line-numbers-mode 1)
              (view-mode-hook--origami)))
#+END_SRC

*** Mesonモード

#+BEGIN_SRC emacs-lisp
  (add-hook 'meson-mode
            (lambda ()
              (display-line-numbers-mode)))
#+END_SRC

*** CSSモード

#+BEGIN_SRC emacs-lisp
  (add-hook 'css-mode
            (lambda ()
              (display-line-numbers-mode)))
#+END_SRC

*** コンパイラー設定

#+BEGIN_SRC emacs-lisp
  (require 'ansi-color)
  (defun endless/colorize-compilation ()
    "Colorize from `compilation-filter-start' to `point'."
    (let ((inhibit-read-only t))
      (ansi-color-apply-on-region
       compilation-filter-start (point))))

  (add-hook 'compilation-filter-hook
            #'endless/colorize-compilation)
#+END_SRC

** 追加設定
ここにどう書けばいいかわからないが、カスタマイズ設定の手順も書いとく

*** フォント設定
メニュー → オプション → デフォルトフォントの設定

M-x customize-face line-number,line-number-current-line,org-block,org-block-begin-line,org-block-end-line

フォントの個別設定をする。

